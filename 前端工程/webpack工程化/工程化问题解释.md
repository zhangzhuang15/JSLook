### 为什么编写scss时，可以使用@符号作为路径别名？
首先处理scss代码是通过loader和scss编译器完成的，而scss编译器一般会有配置文件，在配置文件中可以设置@符号作为路径别名，于是在webpack打包时，会调用loader去处理，而loader又会调用scss编译器去处理，而scss编译器在处理前，又会查看配置文件中的信息，这样就可以解析@符号了。

---

### 为什么js可以从@符号路径中import模块？
webpack本身就可以处理js代码，在webpack配置文件中可以设置@符号路径，在处理js的import时，webpack就会识别@符号路径。

---

### 项目用ts写的，webpack怎么打包成js代码的？
一种是tsc的思路，webpack用ts-loader处理ts文件，ts-loader会调用tsc处理ts文件，因此项目中同时会有ts的配置文件存在。经过ts-loader处理后，ts代码转化为js代码，此时webpack可以继续用babel-loader处理js代码，变成兼容性更好、拥有pollyfill的js代码。
> 这种方式因为经历了tsc，因此在ts配置文件中可以设置@符号路径，并在ts代码的import路径中使用。

另一种是babel的思路，自babel7开始，babel就可以编译ts代码了，此时webpack只需要babel-loader和babel配置文件，就可以将ts转换为js了。
> 比如需要@babel/preset-typescript, @babel/preset-env

---

### 为什么scss变量可以在scss文件中直接全局使用？
sass-resource-loader 的功劳，可以指定哪些scss文件中定义的scss变量和mixins作为全局变量，并于编译期间在其他scss文件中自动插入@import 命令引入它们，实现全局直接使用的效果。

---

### 打包时如何获取环境变量，来区分是dev环境还是test环境？
在执行webpack指令时，可以通过 cross-env 这个npm依赖程序设置环境变量，这样在 webpack.config.js中，可以使用process.env捕捉到环境变量，从而知道是dev还是test。

在 vue2 中，依靠 .env.development 文件， .env.production 文件进行区分，vue/cli工具中执行`vue dev`会读取.env.development文件中的变量，作为环境变量，在 vue.config.js中利用 process.env就可以获取到这些环境变量。